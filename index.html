<!DOCTYPE html>
<html lang="bg">

<head>
  <meta charset="UTF-8" />
  <!-- –î–∞ –Ω–µ zoom-–≤–∞ —Å–ª—É—á–∞–π–Ω–æ, –∫–∞—Ç–æ –∞–ø–ø –∞ –Ω–µ –∫–∞—Ç–æ —Å–∞–π—Ç –¥–∞ –∏–∑–≥–ª–µ–∂–¥–∞ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <link rel="apple-touch-icon" href="favicon.svg" />
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#121212" />

  <title>Pro Fitness Timer & DJ</title>
  <style>
    :root {
      --bg-color: #121212;
      --text-color: #ffffff;
      --accent: #00e676;
      /* –ó–µ–ª–µ–Ω–æ –∑–∞ —Ä–∞–±–æ—Ç–∞ */
      --accent-rest: #ff1744;
      /* –ß–µ—Ä–≤–µ–Ω–æ –∑–∞ –ø–æ—á–∏–≤–∫–∞ */
      --card-bg: #1e1e1e;
      --highlight: #29b6f6;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 10px;
      font-size: 1.5rem;
      text-align: center;
    }

    /* Settings Panel */
    .settings {
      background: var(--card-bg);
      padding: 15px;
      border-radius: 10px;
      width: 100%;
      max-width: 400px;
      display: flex;
      /* –ü—Ä–æ–º–µ–Ω–µ–Ω–æ –æ—Ç grid –Ω–∞ flex */
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
      box-sizing: border-box;
    }

    .input-group {
      display: flex;
      flex-direction: column;
    }

    label {
      font-size: 0.8rem;
      color: #aaa;
      margin-bottom: 5px;
    }

    input[type="number"] {
      padding: 8px;
      background: #333;
      border: 1px solid #444;
      color: #fff;
      border-radius: 5px;
      font-size: 1.1rem;
      text-align: center;
    }

    /* Checkbox groups */
    .checkbox-group {
      grid-column: span 2;
      display: flex;
      flex-direction: column;
      gap: 8px;
      border-top: 1px solid #333;
      padding-top: 10px;
    }

    .cb-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      /* –ü—Ä–æ–º–µ–Ω–µ–Ω–æ –Ω–∞ flex-start –∑–∞ –ø–æ–¥—Ä–∞–≤–Ω—è–≤–∞–Ω–µ –Ω–∞–ª—è–≤–æ */
      gap: 15px;
      /* –†–∞–∑—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–µ–∫—Å—Ç–∞ –∏ —á–µ–∫–±–æ–∫—Å–∞ */
    }

    .cb-row label {
      margin: 0;
      font-size: 0.9rem;
      color: #ddd;
    }

    input[type="checkbox"] {
      transform: scale(1.5);
      accent-color: var(--highlight);
    }

    /* Timer Display */
    .timer-display {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
      max-width: 400px;
      padding: 20px 0;
      border-radius: 15px;
      background: var(--card-bg);
      border: 3px solid var(--accent);
      transition: border-color 0.3s, background-color 0.3s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    }

    .status-text {
      font-size: 2rem;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .time-text {
      font-size: 5.5rem;
      font-weight: bold;
      line-height: 1;
      margin: 10px 0;
      font-variant-numeric: tabular-nums;
    }

    .set-text {
      font-size: 1.2rem;
      color: #aaa;
    }

    .rest-mode {
      border-color: var(--accent-rest);
    }

    .rest-mode .status-text {
      color: var(--accent-rest);
    }

    .work-mode .status-text {
      color: var(--accent);
    }

    .finished-mode {
      border-color: var(--highlight);
    }

    .finished-mode .status-text {
      color: var(--highlight);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      width: 100%;
      max-width: 400px;
    }

    button {
      padding: 15px 0;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      text-transform: uppercase;
      transition: transform 0.1s;
    }

    button:active {
      transform: scale(0.95);
    }

    .btn-start {
      background-color: var(--accent);
      color: #000;
      flex: 1;
    }

    .btn-stop {
      background-color: var(--accent-rest);
      color: #fff;
      flex: 1;
    }

    .btn-reset {
      background-color: #444;
      color: #fff;
      flex: 1;
    }

    /* Music Player */
    .player {
      width: 100%;
      max-width: 400px;
      background: var(--card-bg);
      padding: 15px;
      border-radius: 10px;
      box-sizing: border-box;
    }

    .file-input-wrapper {
      margin-bottom: 10px;
    }

    input[type="file"] {
      width: 100%;
      color: #aaa;
    }

    .now-playing {
      margin: 10px 0;
      font-style: italic;
      color: var(--highlight);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9rem;
    }

    .playlist {
      max-height: 150px;
      overflow-y: auto;
      list-style: none;
      padding: 0;
      margin: 0;
      border-top: 1px solid #333;
    }

    .playlist li {
      padding: 10px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
    }

    .playlist li:hover {
      background: #2a2a2a;
    }

    .playlist li.active {
      background: #333;
      color: var(--highlight);
      font-weight: bold;
    }

    audio {
      width: 100%;
      margin-top: 10px;
    }

    /* –°–∫—Ä–∏–≤–∞–Ω–µ –∏ –ø–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ */
    .settings {
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out,
        padding 0.3s;
      max-height: 1000px;
      /* –î–æ—Å—Ç–∞—Ç—ä—á–Ω–æ –≥–æ–ª—è–º–æ —á–∏—Å–ª–æ */
      opacity: 1;
      overflow: hidden;
    }

    .settings.collapsed {
      max-height: 0;
      opacity: 0;
      padding: 0;
      margin: 0;
      /* –ú–∞—Ö–∞–º–µ –º–∞—Ä–¥–∂–∏–Ω–∞, –∫–æ–≥–∞—Ç–æ –µ –∑–∞—Ç–≤–æ—Ä–µ–Ω–æ */
      pointer-events: none;
      visibility: hidden;
      /* –ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞, —á–µ –µ–ª–µ–º–µ–Ω—Ç—ä—Ç –Ω–µ –≤–ª–∏—è–µ –Ω–∞ –ø–æ–¥—Ä–µ–¥–±–∞—Ç–∞ */
    }

    .settings-toggle {
      background: transparent;
      border: 1px solid #444;
      color: var(--highlight);
      /* –ú–∞–ª—ä–∫ –≤–µ—Ä—Ç–∏–∫–∞–ª–µ–Ω (8px) –∏ –≥–æ–ª—è–º —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–µ–Ω (40px) –ø–∞–¥–¥–∏–Ω–≥ –∑–∞ —à–∏—Ä–æ–∫ –≤–∏–¥ */
      padding: 8px 40px;
      margin: 10px auto 20px auto;

      /* –ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞–º–µ, —á–µ –Ω—è–º–∞ –¥–∞ —Å–µ —Ä–∞–∑–ø—ä–≤–∞ –Ω–∞–≥–æ—Ä–µ/–Ω–∞–¥–æ–ª—É */
      width: fit-content;
      height: fit-content;
      min-height: 0;

      display: flex;
      align-items: center;
      justify-content: center;

      cursor: pointer;
      font-size: 0.85rem;
      font-weight: bold;
      text-transform: uppercase;
      border-radius: 30px;
      /* –ó–∞–æ–±–ª–µ–Ω "pill" –¥–∏–∑–∞–π–Ω */
      transition: all 0.2s;
    }

    .settings-toggle:hover {
      background: rgba(41, 182, 246, 0.1);
      border-color: var(--highlight);
    }

    /* –¶–≤–µ—Ç–æ–≤–µ –∑–∞ –ø—Ä–æ–≥—Ä–µ—Å –±–∞—Ä–∞ —Å–ø–æ—Ä–µ–¥ —Ä–µ–∂–∏–º–∞ */
    .rest-mode #progressBar {
      background-color: var(--accent-rest) !important;
    }

    .work-mode #progressBar {
      background-color: var(--accent) !important;
    }

    .finished-mode #progressBar {
      width: 0% !important;
    }

    /* ---------- Theme variables: –¥–æ–±–∞–≤—è—Ç —Å–µ —Å–ª–µ–¥ :root ---------- */
    /* –ü–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –æ—Å—Ç–∞–≤–∞–º–µ –≤ dark mode (–∫–∞–∫—Ç–æ –∏–º–∞—à –≤ :root),
		   –Ω–æ —Ç—É–∫ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ —è—Å–Ω–∞ light —Ç–µ–º–∞ –∏ –Ω—è–∫–æ–∏ –≥–ª–æ–±–∞–ª–Ω–∏ –ø–æ–ø—Ä–∞–≤–∫–∏. */

    .light-theme {
      --bg-color: #f7f7f8;
      --text-color: #0f1720;
      --card-bg: #ffffff;
      --input-bg: #ffffff;
      --input-border: #dcdcdc;
      --accent: #0077cc;
      /* —Å–∏–Ω –∞–∫—Ü–µ–Ω—Ç –∑–∞ –≤–∏–¥–∏–º–æ—Å—Ç –≤ —Å–≤–µ—Ç—ä–ª —Ä–µ–∂–∏–º */
      --accent-rest: #c62828;
      --highlight: #0b84ff;
      --muted: #6b7280;
      --panel-shadow: 0 6px 18px rgba(16, 24, 40, 0.06);
      --progress-bg: #e6e6e6;
    }

    .dark-theme {
      /* –ú–æ–∂–µ—à –¥–∞ –æ—Å—Ç–∞–≤–∏—à —Å—Ç–æ–π–Ω–æ—Å—Ç–∏—Ç–µ –æ—Ç :root (–≤–µ—á–µ —Å–∞ —Ç—ä–º–Ω–∏),
			 –Ω–æ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ —è–≤–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –∑–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç */
      --bg-color: #121212;
      --text-color: #ffffff;
      --card-bg: #1e1e1e;
      --input-bg: #2b2b2b;
      --input-border: #444;
      --accent: #00e676;
      --accent-rest: #ff1744;
      --highlight: #29b6f6;
      --muted: #9ca3af;
      --panel-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      --progress-bg: #2a2a2a;
    }

    /* –ü–ª–∞–≤–µ–Ω –ø—Ä–µ—Ö–æ–¥ –ø—Ä–∏ —Å–º—è–Ω–∞ –Ω–∞ —Ç–µ–º–∞ */
    body {
      transition: background-color 240ms ease, color 240ms ease;
    }

    /* Theme toggle button */
    .theme-toggle-wrapper {
      width: 100%;
      max-width: 400px;
      display: flex;
      justify-content: flex-end;
      margin-bottom: 8px;
      box-sizing: border-box;
    }

    .theme-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--input-border);
      background: linear-gradient(180deg,
          rgba(255, 255, 255, 0.02),
          rgba(0, 0, 0, 0.02));
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
      transition: background 160ms, border-color 160ms, transform 80ms;
      color: var(--text-color);
    }

    .theme-toggle-btn:active {
      transform: scale(0.98);
    }

    .theme-toggle-btn:focus {
      outline: 3px solid rgba(11, 132, 255, 0.18);
      outline-offset: 2px;
    }

    /* Icons inside button: –ø–æ–∫–∞–∑–≤–∞–º–µ/—Å–∫—Ä–∏–≤–∞–º–µ —Å–ø—Ä—è–º–æ —Ç–µ–º–∞ */
    .icon-sun,
    .icon-moon {
      display: inline-block;
    }

    .light-theme .icon-sun {
      opacity: 1;
      transform: translateY(0);
    }

    .light-theme .icon-moon {
      opacity: 0.35;
      transform: translateY(0);
    }

    .dark-theme .icon-sun {
      opacity: 0.35;
      transform: translateY(0);
    }

    .dark-theme .icon-moon {
      opacity: 1;
      transform: translateY(0);
    }

    /* Visually hidden for screen readers */
    .visually-hidden {
      position: absolute !important;
      height: 1px;
      width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
    }

    /* Override –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏ –º–µ—Å—Ç–∞ –≤ —Ç–≤–æ—è —Å—Ç–∏–ª, –∑–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ: */
    input[type="number"],
    input[type="file"] {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text-color);
    }

    .settings {
      background: var(--card-bg);
      box-shadow: var(--panel-shadow);
    }

    .timer-display {
      background: var(--card-bg);
      color: var(--text-color);
    }

    .player {
      background: var(--card-bg);
      color: var(--text-color);
      box-shadow: var(--panel-shadow);
    }

    .now-playing {
      color: var(--highlight);
    }

    /* Playlist hover/active */
    .playlist li:hover {
      background: color-mix(in srgb, var(--highlight) 10%, transparent);
    }

    .playlist li.active {
      background: color-mix(in srgb, var(--highlight) 12%, transparent);
      color: var(--highlight);
    }

    /* Buttons: ensure contrast with text */
    .btn-start {
      background-color: var(--accent);
      color: var(--text-color);
    }

    .btn-stop {
      background-color: var(--accent-rest);
      color: var(--text-color);
    }

    .btn-reset {
      background-color: color-mix(in srgb, var(--text-color) 8%, transparent);
      color: var(--text-color);
    }

    /* Progress bar base */
    .progress-container {
      background: var(--progress-bg);
      border-color: var(--input-border);
    }

    /* Ensure progress text contrast */
    #progressPercent {
      color: var(--text-color);
      text-shadow: none;
    }

    /* Accessibility: focus for interactive list items */
    .playlist li:focus {
      outline: 2px solid rgba(11, 132, 255, 0.18);
      outline-offset: -2px;
    }

    /* Small responsiveness for toggle (mobile) */
    @media (max-width: 420px) {
      .theme-toggle-wrapper {
        justify-content: center;
        margin-bottom: 6px;
      }
    }

    /* Header: h1 + theme toggle –Ω–∞ –µ–¥–∏–Ω —Ä–µ–¥ */
    .header-row {
      width: 100%;
      max-width: 400px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .header-row h1 {
      margin: 0;
      font-size: 1.6rem;
      line-height: 1.2;
      text-align: left;
      flex: 1;
    }

    /* –ù–∞ –º–Ω–æ–≥–æ –º–∞–ª–∫–∏ –µ–∫—Ä–∞–Ω–∏ ‚Äì –∑–∞–ø–∞–∑–≤–∞–º–µ —á–µ—Ç–∏–º–æ—Å—Ç */
    @media (max-width: 380px) {
      .header-row h1 {
        font-size: 1.4rem;
      }
    }

    /* Light theme: –ø–æ-–¥–æ–±—Ä–∞ —á–µ—Ç–∏–º–æ—Å—Ç –Ω–∞ checkbox —Ç–µ–∫—Å—Ç–æ–≤–µ—Ç–µ */
    .light-theme label {
      color: #2f2f2f;
      /* —Ç—ä–º–Ω–æ —Å–∏–≤–æ ‚Äì –ø–æ-–º–µ–∫–æ –æ—Ç —á–∏—Å—Ç–æ —á–µ—Ä–Ω–æ */
    }

    /* –°–∞–º–∏—Ç–µ —á–µ–∫–±–æ–∫—Å–æ–≤–µ */
    .light-theme input[type="checkbox"] {
      accent-color: #555;
      /* —Ç—ä–º–Ω–æ —Å–∏–≤–æ, –Ω–µ —á–µ—Ä–Ω–æ */
    }

    button,
    input[type="checkbox"] {
      touch-action: manipulation;
      /* –ü—Ä–µ–º–∞—Ö–≤–∞ –∑–∞–±–∞–≤—è–Ω–µ—Ç–æ –ø—Ä–∏ —Ç–∞–ø–≤–∞–Ω–µ –Ω–∞ –º–æ–±–∏–ª–Ω–∏ */
      -webkit-tap-highlight-color: transparent;
      /* –ú–∞—Ö–∞ —Å–∏–Ω–∏–æ—Ç–æ –∫–≤–∞–¥—Ä–∞—Ç—á–µ –ø—Ä–∏ —Ç–∞–ø */
    }

    /* Player Controls - –ì–æ–ª–µ–º–∏ –±—É—Ç–æ–Ω–∏ –∑–∞ —Ç–µ–ª–µ—Ñ–æ–Ω */
    .player-controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      justify-content: space-between;
    }

    .player-btn {
      background: #333;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 12px;
      font-size: 1.2rem;
      flex: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .player-btn:active {
      background: #555;
      transform: scale(0.95);
    }

    /* –ê–∫—Ç–∏–≤–µ–Ω Shuffle –±—É—Ç–æ–Ω */
    .btn-shuffle.active {
      color: var(--highlight);
      background: rgba(41, 182, 246, 0.15);
      border: 1px solid var(--highlight);
    }

    /* –°–∫—Ä–∏–≤–∞–º–µ –∏—Å—Ç–∏–Ω—Å–∫–∏—è –∏–Ω–ø—É—Ç */
    #audioFiles {
      display: none;
    }

    /* –°—Ç–∏–ª–∏–∑–∏—Ä–∞–º–µ –ª–µ–π–±—ä–ª–∞ –∫–∞—Ç–æ –±—É—Ç–æ–Ω */
    .custom-file-upload {
      display: inline-block;
      padding: 12px 20px;
      cursor: pointer;
      background-color: var(--highlight);
      color: #000;
      border-radius: 8px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9rem;
      text-align: center;
      transition: transform 0.1s, background-color 0.2s;
      width: 100%;
      box-sizing: border-box;
    }

    .custom-file-upload:active {
      transform: scale(0.98);
    }

    .custom-file-upload:hover {
      background-color: color-mix(in srgb, var(--highlight) 85%, white);
    }

    /* Presets Styles */
    .presets-container {
      margin-top: 20px;
      border-top: 1px solid #333;
      padding-top: 15px;
    }

    .preset-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .preset-input {
      flex: 1;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #444;
      background: var(--input-bg);
      color: var(--text-color);
    }

    .btn-save-preset {
      background: var(--highlight);
      color: #000;
      border: none;
      border-radius: 5px;
      padding: 0 15px;
      font-weight: bold;
      cursor: pointer;
    }

    .presets-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 200px;
      overflow-y: auto;
    }

    .preset-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.05);
      margin-bottom: 5px;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .preset-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .preset-name {
      flex: 1;
      font-weight: 500;
    }

    .preset-delete {
      background: none;
      border: none;
      color: var(--accent-rest);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0 5px;
      margin-left: 10px;
    }

    .preset-delete:hover {
      transform: scale(1.1);
    }

    /* Info Modal Styles */
    .about-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0 10px;
      transition: transform 0.2s;
    }

    .about-btn:hover {
      transform: scale(1.2);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: var(--card-bg);
      /* Use theme variable */
      color: var(--text-color);
      padding: 30px;
      border-radius: 15px;
      max-width: 500px;
      width: 100%;
      position: relative;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      border: 1px solid #333;
      text-align: center;
    }

    .light-theme .modal-content {
      border-color: #ddd;
    }

    .modal-close {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      font-size: 2rem;
      color: var(--text-color);
      cursor: pointer;
      line-height: 1;
    }

    .modal-content h2 {
      margin-top: 0;
      color: var(--highlight);
      font-size: 1.8rem;
    }

    .modal-desc {
      font-size: 1rem;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .pwa-install-btn {
      background-color: var(--highlight);
      color: #000;
      border: none;
      padding: 12px 25px;
      font-size: 1rem;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: none;
      /* Hidden by default until event fires */
      margin-top: 15px;
    }

    .pwa-install-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px var(--highlight);
    }

    /* --- Spotify Specific Styles --- */
    .spotify-login-container {
      text-align: center;
      padding: 20px;
    }

    .spotify-btn {
      background-color: #1DB954;
      /* Spotify Green */
      color: #fff;
      font-weight: bold;
      border-radius: 50px;
      padding: 12px 30px;
      font-size: 1rem;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      text-transform: uppercase;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .spotify-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(29, 185, 84, 0.5);
    }

    .spotify-player {
      display: none;
      /* Hidden until logged in */
      flex-direction: column;
      gap: 15px;
    }

    .spotify-profile {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: #aaa;
      justify-content: space-between;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }

    .spotify-user-badge {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .premium-badge {
      background: #ffd700;
      color: #000;
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: bold;
    }

    .spotify-select {
      width: 100%;
      padding: 10px;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text-color);
      border-radius: 5px;
      font-size: 1rem;
    }

    .spotify-controls {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .sp-control-btn {
      background: #333;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .sp-control-btn:hover {
      background: #444;
      color: var(--highlight);
    }

    .sp-control-btn.play-btn {
      background: var(--highlight);
      color: #000;
      transform: scale(1.1);
    }

    /* Device Warning */
    .device-warning {
      color: var(--accent-rest);
      font-size: 0.85rem;
      text-align: center;
      margin-top: 5px;
      display: none;
    }

    /* Song List Styles */
    .song-list {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #333;
      border-radius: 5px;
      background: #111;
    }

    .song-item {
      padding: 8px;
      border-bottom: 1px solid #333;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
    }

    .song-item:hover {
      background: #222;
    }

    .song-item.active {
      color: #FF0000;
      background: #220000;
    }

    .song-thumb {
      width: 40px;
      height: 30px;
      object-fit: cover;
      margin-right: 10px;
      border-radius: 3px;
    }
  </style>
</head>

<body>
  <div class="header-row">
    <h1>üèãÔ∏è‚Äç‚ôÇÔ∏è Fitness Timer & DJ</h1>
    <button id="aboutBtn" class="about-btn" onclick="toggleInfoModal()" aria-label="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
      title="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ">‚ÑπÔ∏è</button>

    <button id="themeToggle" class="theme-toggle-btn" aria-pressed="false" aria-label="–ü—Ä–µ–≤–∫–ª—é—á–∏ —Å–≤–µ—Ç–ª–∞/—Ç—ä–º–Ω–∞ —Ç–µ–º–∞"
      title="–°–º—è–Ω–∞ —Ç–µ–º–∞">
      <span class="icon-sun" aria-hidden="true">‚òÄÔ∏è</span>
      <span class="icon-moon" aria-hidden="true">üåô</span>
      <span class="visually-hidden">–°–º—è–Ω–∞ —Ç–µ–º–∞</span>
    </button>
  </div>

  <button class="settings-toggle" onclick="toggleSettings()">
    ‚ò∞ –ù–∞—Å—Ç—Ä–æ–π–∫–∏
  </button>

  <div class="settings" id="settingsPanel">
    <div class="input-group">
      <label>–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ (—Å–µ–∫)</label>
      <input type="number" id="prepTime" value="10" min="0" oninput="if(this.value<0)this.value=0" />
    </div>
    <div class="input-group">
      <label>–†–∞–±–æ—Ç–∞ (—Å–µ–∫)</label>
      <input type="number" id="workTime" value="30" min="0" oninput="if(this.value<0)this.value=0" />
    </div>
    <div class="input-group">
      <label>–ü–æ—á–∏–≤–∫–∞ (—Å–µ–∫)</label>
      <input type="number" id="restTime" value="5" min="0" oninput="if(this.value<0)this.value=0" />
    </div>
    <div class="input-group">
      <label>–°–µ—Ä–∏–∏ (–±—Ä–æ–π)</label>
      <input type="number" id="sets" value="8" min="1" oninput="if(this.value<1)this.value=1" />
    </div>

    <div class="input-group" style="margin-top: 5px; text-align: center;">
      <div id="totalTimeDisplay"
        style="font-size: 1.2rem; color: var(--highlight); font-weight: bold; border: 1px solid var(--highlight); padding: 10px; border-radius: 8px;">
        –û–±—â–æ: 00:00
      </div>
    </div>

    <div class="checkbox-group">
      <div class="input-group">
        <label>–û—Ç–±—Ä–æ—è–≤–∞–Ω–µ –≥–ª–∞—Å (—Å–µ–∫)</label>
        <input type="number" id="voiceCountdown" value="5" min="0" oninput="if(this.value<0)this.value=0" />
      </div>

      <div class="cb-row">
        <input type="checkbox" id="countBeforeRest" checked />
        <label for="countBeforeRest">–û—Ç–±—Ä–æ—è–≤–∞–π –ø—Ä–µ–¥–∏ –ü–û–ß–ò–í–ö–ê</label>
      </div>
      <div class="cb-row">
        <input type="checkbox" id="countBeforeWork" checked />
        <label for="countBeforeWork">–û—Ç–±—Ä–æ—è–≤–∞–π –ø—Ä–µ–¥–∏ –°–ï–†–ò–Ø (GO)</label>
      </div>
      <div class="cb-row">
        <input type="checkbox" id="stopMusicOnFinish" />
        <label for="stopMusicOnFinish">–°–ø—Ä–∏ –º—É–∑–∏–∫–∞—Ç–∞ –ø—Ä–∏ –§–ò–ù–ê–õ</label>
      </div>
    </div>

    <!-- Presets Section -->
    <div class="presets-container">
      <label style="display:block; margin-bottom:8px; color:var(--highlight); font-weight:bold;">üíæ –ó–∞–ø–∞–∑–µ–Ω–∏
        –†–µ–∂–∏–º–∏</label>
      <div class="preset-controls">
        <input type="text" id="presetName" class="preset-input" placeholder="–ò–º–µ (–Ω–∞–ø—Ä. BOOTY üçë)" />
        <button class="btn-save-preset" onclick="savePreset()">Save</button>
      </div>
      <ul id="presetsList" class="presets-list">
        <!-- Presets will be loaded here -->
      </ul>
    </div>

  </div>
  </div>

  <div class="timer-display work-mode" id="timerDisplay">
    <div class="status-text" id="statusText">–ì–û–¢–û–í?</div>
    <div class="time-text" id="timeText">00</div>
    <div class="set-text" id="setText">–°–µ—Ä–∏—è: 0 / 8</div>
    <br />
    <div class="progress-container" style="
          width: 100%;
          height: 20px;
          background: #333;
          margin-bottom: 20px;
          overflow: hidden;
          border: 1px solid #444;
          position: relative;
        ">
      <div id="progressBar" style="
            width: 0%;
            height: 100%;
            background: var(--highlight);
            transition: width 0.3s ease-out;
          "></div>
      <div id="progressPercent" style="
            position: absolute;
            width: 100%;
            top: 0;
            left: 0;
            text-align: center;
            font-size: 0.8rem;
            line-height: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
          ">
        0%
      </div>
    </div>
  </div>

  <div class="controls">
    <button class="btn-start" onclick="startTimer()">Start</button>
    <button class="btn-stop" onclick="stopTimer()">Pause</button>
    <button class="btn-reset" onclick="resetTimer()">Reset</button>
  </div>

  <div class="player">
    <div
      style="display:flex; justify-content:space-around; margin-bottom:15px; border-bottom:1px solid #333; padding-bottom:10px;">
      <button type="button" onclick="switchMusicService('spotify')" id="tabSpotify"
        style="background:transparent; color:#1DB954; font-weight:bold; border:none; border-bottom:2px solid #1DB954; padding:5px;">Spotify</button>
      <button type="button" onclick="switchMusicService('youtube')" id="tabYouTube"
        style="background:transparent; color:#aaa; font-weight:normal; border:none; padding:5px;">YouTube Music</button>
    </div>

    <!-- SPOTIFY SECTION -->
    <div id="sectionSpotify">
      <h3><span style="color:#1DB954">üéµ</span> Spotify DJ</h3>

      <!-- Login Section -->
      <div id="spotifyLogin" class="spotify-login-container">
        <p style="margin-bottom:15px; font-size:0.9rem; color:#aaa;">
          –°–≤—ä—Ä–∂–µ—Ç–µ Premium –∞–∫–∞—É–Ω—Ç –∑–∞ –¥–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–∞—Ç–µ –º—É–∑–∏–∫–∞—Ç–∞ –¥–∏—Ä–µ–∫—Ç–Ω–æ.
        </p>
        <button class="spotify-btn" onclick="SpotifyController.login()">
          Login with Spotify
        </button>
      </div>

      <!-- Player Interface -->
      <div id="spotifyPlayerUI" class="spotify-player">
        <div class="spotify-profile">
          <div class="spotify-user-badge">
            <span id="spUserName">User</span>
            <span id="spPlanBadge" class="premium-badge" style="display:none">PREMIUM</span>
          </div>
          <button onclick="SpotifyController.logout()"
            style="background:none; border:none; color:#aaa; cursor:pointer; font-size:0.8rem; text-decoration:underline;">Logout</button>
        </div>

        <!-- Device Warning -->
        <div id="spDeviceWarning" class="device-warning">
          ‚ö†Ô∏è –ù—è–º–∞ –∞–∫—Ç–∏–≤–µ–Ω Spotify Player. –û—Ç–≤–æ—Ä–µ—Ç–µ Spotify –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ —Å–∏ –∏ –ø—É—Å–Ω–µ—Ç–µ –Ω–µ—â–æ –∑–∞ —Å—Ç–∞—Ä—Ç.
        </div>

        <!-- Playlist Selector -->
        <div>
          <label style="font-size:0.8rem; color:#aaa;">–ò–∑–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç</label>
          <select id="spPlaylistSelect" class="spotify-select" onchange="SpotifyController.selectPlaylist(this.value)">
            <option value="">–ó–∞—Ä–µ–∂–¥–∞–Ω–µ...</option>
          </select>
          <button onclick="SpotifyController.refreshPlaylists()"
            style="background:none; border:none; color:var(--highlight); font-size:0.8rem; margin-top:5px; cursor:pointer;">üîÑ
            –û–±–Ω–æ–≤–∏</button>
        </div>

        <!-- Status -->
        <div class="now-playing" id="spNowPlaying" style="text-align:center; min-height:1.2em;">
          - Not Playing -
        </div>

        <!-- Controls -->
        <div class="spotify-controls">
          <button class="sp-control-btn" onclick="SpotifyController.prev()">‚èÆ</button>
          <button class="sp-control-btn play-btn" id="spPlayBtn" onclick="SpotifyController.togglePlay()">‚ñ∂</button>
          <button class="sp-control-btn" onclick="SpotifyController.next()">‚è≠</button>
        </div>

        <!-- Volume -->
        <div style="margin-top: 15px;">
          <label for="volumeSlider"
            style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #aaa; margin-bottom: 5px;">
            <span>Volume (Spotify)</span>
            <span id="volValue">100%</span>
          </label>
          <input type="range" id="volumeSlider" min="0" max="100" step="1" value="100"
            style="width: 100%; height: 6px; accent-color: #1DB954; cursor: pointer;"
            oninput="SpotifyController.setMasterVolume(this.value)">
        </div>
      </div>
    </div> <!-- END of Section Spotify -->

    <!-- YOUTUBE SECTION -->
    <div id="sectionYouTube" style="display:none;">
      <h3><span style="color:#FF0000">üü•</span> YouTube Music DJ</h3>

      <!-- Login -->
      <div id="ytLogin" class="spotify-login-container">
        <p style="margin-bottom:15px; font-size:0.9rem; color:#aaa;">
          –í–ª–µ–∑—Ç–µ —Å Google –∑–∞ –¥–æ—Å—Ç—ä–ø –¥–æ –ø–ª–µ–π–ª–∏—Å—Ç–∏.
        </p>
        <button class="spotify-btn" style="background-color:#FF0000;" onclick="YouTubeController.login()">
          Login with Google
        </button>
      </div>

      <!-- Player UI -->
      <div id="ytPlayerUI" class="spotify-player"> <!-- Reuse class for layout -->
        <div class="spotify-profile">
          <div class="spotify-user-badge">
            <span id="ytUserName">User</span>
          </div>
          <button onclick="YouTubeController.logout()"
            style="background:none; border:none; color:#aaa; cursor:pointer; font-size:0.8rem; text-decoration:underline;">Logout</button>
        </div>

        <!-- Playlist Selector -->
        <div>
          <label style="font-size:0.8rem; color:#aaa;">–ò–∑–±–µ—Ä–∏ –ø–ª–µ–π–ª–∏—Å—Ç</label>
          <select id="ytPlaylistSelect" class="spotify-select" onchange="YouTubeController.selectPlaylist(this.value)">
            <option value="">–ó–∞—Ä–µ–∂–¥–∞–Ω–µ...</option>
          </select>
          <button onclick="YouTubeController.refreshPlaylists()"
            style="background:none; border:none; color:#FF0000; font-size:0.8rem; margin-top:5px; cursor:pointer;">
            üîÑ –û–±–Ω–æ–≤–∏
          </button>
        </div>

        <!-- Status -->
        <div class="now-playing" id="ytNowPlaying" style="text-align:center; min-height:1.2em; color:#FF0000;">
          - Not Playing -
        </div>

        <!-- Controls -->
        <div class="spotify-controls">
          <button class="sp-control-btn" onclick="YouTubeController.prev()">‚èÆ</button>

          <button class="sp-control-btn" onclick="YouTubeController.next()">‚è≠</button>
        </div>

        <!-- Song List -->
        <div id="ytSongList" class="song-list">
          <!-- Songs loaded here -->
          <div style="padding:10px; text-align:center; color:#666;">Select a playlist to see songs</div>
        </div>

        <!-- Volume -->
        <div style="margin-top: 15px;">
          <label for="ytVolumeSlider"
            style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #aaa; margin-bottom: 5px;">
            <span>Volume (YouTube)</span>
            <span id="ytVolValue">100%</span>
          </label>
          <input type="range" id="ytVolumeSlider" min="0" max="100" step="1" value="100"
            style="width: 100%; height: 6px; accent-color: #FF0000; cursor: pointer;"
            oninput="YouTubeController.setVolume(this.value)">
        </div>

        <!-- Hidden Iframe Container -->
        <div id="player-container"
          style="position: absolute; width: 0; height: 0; overflow: hidden; opacity: 0; pointer-events: none;">
          <div id="yt_player_div"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="wakeLockContainer" style="
        display: none;
        margin-top: 20px;
        text-align: center;
        width: 100%;
        max-width: 400px;
      "></div>

  <script>
    // --- Wake Lock Variable ---
    let wakeLock = null;
    const wakeLockContainer = document.getElementById("wakeLockContainer");

    // –§—É–Ω–∫—Ü–∏—è –∑–∞ –∞–∫—Ç–∏–≤–∏—Ä–∞–Ω–µ –Ω–∞ Wake Lock (–î—ä—Ä–∂–∏ –µ–∫—Ä–∞–Ω–∞ —Å–≤–µ—Ç–Ω–∞—Ç)
    async function requestWakeLock() {
      try {
        if ("wakeLock" in navigator) {
          wakeLock = await navigator.wakeLock.request("screen");
          console.log("üí° Screen Wake Lock active");
        }
      } catch (err) {
        console.error(`‚ùå Wake Lock error: ${err.name}, ${err.message}`);
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞ –æ—Å–≤–æ–±–æ–∂–¥–∞–≤–∞–Ω–µ –Ω–∞ –µ–∫—Ä–∞–Ω–∞
    async function releaseWakeLock() {
      if (wakeLock !== null) {
        await wakeLock.release();
        wakeLock = null;
        console.log("üåë Screen Wake Lock released");
      }
      if (wakeLockContainer) wakeLockContainer.style.display = "none";
    }

    function playBeep(frequency = 440, duration = 0.1) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);

      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(
        0.01,
        audioCtx.currentTime + duration
      );

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    // -------------------------------------------------------
    // 1. –õ–û–ì–í–ê–ù–ï –ò –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê (SYSTEM LOGGING)
    // -------------------------------------------------------
    window.addEventListener("load", () => {
      console.log(
        "%c‚úÖ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –µ –∑–∞—Ä–µ–¥–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ.",
        "color: green; font-weight: bold; font-size: 14px;"
      );
    });

    window.addEventListener("error", (event) => {
      console.error("‚ùå –ì–ª–æ–±–∞–ª–Ω–∞ –≥—Ä–µ—à–∫–∞ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ:", event.message);
    });

    // -------------------------------------------------------
    // 3. MAIN LOGIC
    // -------------------------------------------------------
    // --- USER CONFIGURATION ---
    const GOOGLE_CLIENT_ID = '8243901772-es4u28j6b51ke395q3g5g0i0ktdkl4ti.apps.googleusercontent.com'; // <--- –í–™–í–ï–î–ï–¢–ï –í–ê–®–ò–Ø CLIENT ID –¢–£–ö

    let prepDuration = 10;
    let isPrep = false;

    let workDuration = 30;
    let restDuration = 5;
    let totalSets = 8;

    let currentSet = 1;
    let currentTime = 0;
    let isWork = true;
    let timerInterval = null;
    let isRunning = false;

    let countdownThreshold = 5;
    let totalWorkoutSeconds = 0;
    let elapsedSeconds = 0;

    // DOM Elements
    const statusText = document.getElementById("statusText");
    const timeText = document.getElementById("timeText");
    const setText = document.getElementById("setText");
    const timerDisplay = document.getElementById("timerDisplay");
    const audioPlayer = document.getElementById("audioPlayer");
    const playlistEl = document.getElementById("playlist");
    const nowPlayingEl = document.getElementById("nowPlaying");

    const cbBeforeRest = document.getElementById("countBeforeRest");
    const cbBeforeWork = document.getElementById("countBeforeWork");

    // Audio Logic
    // const audioCtx is already defined above? No, it was in the block I removed.
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playVictorySound() {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const t = audioCtx.currentTime;
      const playNote = (freq, time, duration) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(freq, time);
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(time);
        osc.stop(time + duration);
      };

      playNote(523.25, t, 0.4);
      playNote(659.25, t + 0.1, 0.4);
      playNote(783.99, t + 0.2, 0.4);
      playNote(1046.5, t + 0.4, 0.8);

      const osc2 = audioCtx.createOscillator();
      const gain2 = audioCtx.createGain();
      osc2.type = "sine";
      osc2.frequency.setValueAtTime(1200, t);
      osc2.frequency.linearRampToValueAtTime(2000, t + 0.5);
      gain2.gain.setValueAtTime(0.1, t);
      gain2.gain.linearRampToValueAtTime(0, t + 0.5);
      osc2.connect(gain2);
      gain2.connect(audioCtx.destination);
      osc2.start(t);
      osc2.stop(t + 0.5);
    }

    // --- Spotify Controller Implementation ---
    const SpotifyController = {
      // CONFIG - USER MUST FILL THIS
      clientId: 'YOUR_SPOTIFY_CLIENT_ID_HERE', // <--- –ü–û–ü–™–õ–ù–ò –¢–£–ö
      redirectUri: window.location.origin + window.location.pathname,
      scopes: 'user-read-private user-read-email playlist-read-private playlist-read-collaborative user-modify-playback-state user-read-playback-state',

      // State
      accessToken: localStorage.getItem('sp_access_token'),
      refreshToken: localStorage.getItem('sp_refresh_token'),
      expiry: parseInt(localStorage.getItem('sp_expiry') || '0'),
      userVolume: parseInt(localStorage.getItem('sp_volume') || '100'),
      deviceId: null,
      isDucked: false,

      // --- AUTH ---
      async login() {
        if (window.location.protocol === 'file:') {
          alert('Spotify Auth requires http/https (localhost). It does not work on file://.');
          return;
        }
        if (this.clientId === 'YOUR_SPOTIFY_CLIENT_ID_HERE') {
          prompt("–ú–æ–ª—è –∑–∞–¥–∞–π—Ç–µ Spotify Client ID –≤ –∫–æ–¥–∞ (—Ä–µ–¥ ~1100).", "–í–∑–µ–º–µ—Ç–µ –≥–æ –æ—Ç develoepr.spotify.com");
          return;
        }

        const codeVerifier = this.generateRandomString(64);
        const codeChallenge = await this.generateCodeChallenge(codeVerifier);

        localStorage.setItem('sp_verifier', codeVerifier);

        const args = new URLSearchParams({
          response_type: 'code',
          client_id: this.clientId,
          scope: this.scopes,
          redirect_uri: this.redirectUri,
          code_challenge_method: 'S256',
          code_challenge: codeChallenge
        });

        window.location = 'https://accounts.spotify.com/authorize?' + args;
      },

      async handleCallback() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        if (code) {
          // Clear URL
          window.history.pushState({}, document.title, window.location.pathname);

          const verifier = localStorage.getItem('sp_verifier');
          const body = new URLSearchParams({
            client_id: this.clientId,
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: this.redirectUri,
            code_verifier: verifier,
          });

          await this.getToken(body);
        } else if (this.accessToken) {
          // Check expiry logic (simple check)
          if (Date.now() > this.expiry) {
            await this.refreshTokenFunc();
          } else {
            this.initUI();
          }
        }
      },

      async refreshTokenFunc() {
        if (!this.refreshToken) { this.logout(); return; }
        const body = new URLSearchParams({
          client_id: this.clientId,
          grant_type: 'refresh_token',
          refresh_token: this.refreshToken
        });
        await this.getToken(body);
      },

      async getToken(body) {
        try {
          const response = await fetch('https://accounts.spotify.com/api/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: body
          });
          if (!response.ok) throw new Error('Token error');
          const data = await response.json();

          this.accessToken = data.access_token;
          if (data.refresh_token) this.refreshToken = data.refresh_token;
          this.expiry = Date.now() + (data.expires_in * 1000);

          localStorage.setItem('sp_access_token', this.accessToken);
          if (this.refreshToken) localStorage.setItem('sp_refresh_token', this.refreshToken);
          localStorage.setItem('sp_expiry', this.expiry);

          this.initUI();
        } catch (e) {
          console.error(e);
          alert("Auth failed. Check console.");
        }
      },

      logout() {
        this.accessToken = null;
        localStorage.removeItem('sp_access_token');
        localStorage.removeItem('sp_refresh_token');
        localStorage.removeItem('sp_expiry');
        // Stop polling
        if (this.pollInterval) clearInterval(this.pollInterval);
        this.initUI();
      },

      // --- UI & Player Logic ---
      async initUI() {
        if (!this.accessToken) {
          // ShoW Login, Hide Player
          document.getElementById('spotifyLogin').style.display = 'block';
          document.getElementById('spotifyPlayerUI').style.display = 'none';
          return;
        }

        // Show Player, Hide Login
        document.getElementById('spotifyLogin').style.display = 'none';
        document.getElementById('spotifyPlayerUI').style.display = 'flex';

        // Restore Volume
        document.getElementById('volumeSlider').value = this.userVolume;
        document.getElementById('volValue').textContent = this.userVolume + '%';

        // Get Profile
        const profile = await this.api('GET', 'me');
        if (profile) {
          document.getElementById('spUserName').textContent = profile.display_name;
          if (profile.product === 'premium') {
            document.getElementById('spPlanBadge').style.display = 'inline-block';
          } else {
            console.warn("Spotify: Account is not Premium.");
          }
        } else {
          // If profile fetch failed (likely 401), initUI might be called again by logout
          return;
        }

        this.refreshPlaylists();
        this.startPolling();
      },

      async refreshPlaylists() {
        if (!this.accessToken) return;
        const data = await this.api('GET', 'me/playlists?limit=50');
        const sel = document.getElementById('spPlaylistSelect');
        sel.innerHTML = '<option value="">-- –ò–∑–±–µ—Ä–∏ –ü–ª–µ–π–ª–∏—Å—Ç --</option>';
        if (data && data.items) {
          data.items.forEach(p => {
            if (!p) return;
            const opt = document.createElement('option');
            opt.value = p.uri;
            opt.textContent = p.name;
            sel.appendChild(opt);
          });
        }
      },

      async selectPlaylist(uri) {
        if (!uri) return;
        await this.api('PUT', 'me/player/play', { context_uri: uri });
        setTimeout(() => this.updateStatus(), 1000);
      },

      async api(method, endpoint, body = null) {
        if (!this.accessToken) return null; // Safety check
        try {
          if (Date.now() > this.expiry) await this.refreshTokenFunc();

          const opts = {
            method: method,
            headers: { 'Authorization': 'Bearer ' + this.accessToken }
          };
          if (body) {
            opts.headers['Content-Type'] = 'application/json';
            opts.body = JSON.stringify(body);
          }
          const res = await fetch('https://api.spotify.com/v1/' + endpoint, opts);
          if (res.status === 204) return null; // No content
          if (res.status === 401) {
            console.warn("Spotify API 401: Logging out.");
            this.logout();
            return null;
          }
          return await res.json();
        } catch (e) {
          console.error("Spotify API Error", e);
          return null;
        }
      },

      // --- Controls ---
      togglePlay() {
        if (this.lastState && this.lastState.is_playing) {
          this.pause();
        } else {
          this.play();
        }
      },
      async play() { await this.api('PUT', 'me/player/play'); this.updateStatus(); },
      async pause() { await this.api('PUT', 'me/player/pause'); this.updateStatus(); },
      async next() { await this.api('POST', 'me/player/next'); this.updateStatus(); },
      async prev() { await this.api('POST', 'me/player/previous'); this.updateStatus(); },

      // --- Volume & Ducking ---
      setMasterVolume(val) {
        this.userVolume = parseInt(val);
        document.getElementById('volValue').textContent = val + '%';
        localStorage.setItem('sp_volume', val);

        // Apply immediately if not ducked
        if (!this.isDucked) {
          this.applyVolume(this.userVolume);
        } else {
          this.applyVolume(Math.round(this.userVolume * 0.6));
        }
      },

      setDucked(shouldDuck) {
        this.isDucked = shouldDuck;
        const target = shouldDuck ? Math.round(this.userVolume * 0.4) : this.userVolume; // Duck to 40%
        this.applyVolume(target);
      },

      async applyVolume(percent) {
        if (percent < 0) percent = 0;
        if (percent > 100) percent = 100;
        await this.api('PUT', 'me/player/volume?volume_percent=' + percent);
      },

      // --- Polling for Status ---
      lastState: null,
      pollInterval: null,
      startPolling() {
        if (this.pollInterval) clearInterval(this.pollInterval);
        this.pollInterval = setInterval(() => this.updateStatus(), 3000);
        this.updateStatus();
      },

      async updateStatus() {
        if (!this.accessToken) return;
        const data = await this.api('GET', 'me/player');
        if (!data) {
          document.getElementById('spDeviceWarning').style.display = 'block';
          return;
        }
        document.getElementById('spDeviceWarning').style.display = 'none';
        this.lastState = data;

        const track = data.item;
        const isPlaying = data.is_playing;

        const name = track ? (track.name + " - " + track.artists[0].name) : "Paused";
        document.getElementById('spNowPlaying').textContent = (isPlaying ? "‚ñ∂ " : "‚è∏ ") + name;
        document.getElementById('spPlayBtn').textContent = isPlaying ? "‚è∏" : "‚ñ∂";
      }
    };

    // --- MUSIC SERVICE SWITCHING ---
    let activeMusicService = 'spotify'; // 'spotify' | 'youtube'

    function switchMusicService(service) {
      console.log(`üîÄ Switching music service to: ${service}`);
      if (service === activeMusicService) {
        console.log("‚ÑπÔ∏è Already on this service.");
        return;
      }

      // Stop current
      if (activeMusicService === 'spotify') {
        SpotifyController.pause();
      } else if (activeMusicService === 'youtube') {
        YouTubeController.pause();
      }

      activeMusicService = service;

      // Update UI Tabs
      const sBtn = document.getElementById('tabSpotify');
      const yBtn = document.getElementById('tabYouTube');
      const sSec = document.getElementById('sectionSpotify');
      const ySec = document.getElementById('sectionYouTube');

      if (service === 'spotify') {
        sBtn.style.color = '#1DB954';
        sBtn.style.borderBottom = '2px solid #1DB954';
        yBtn.style.color = '#aaa';
        yBtn.style.borderBottom = 'none';

        sSec.style.display = 'block';
        ySec.style.display = 'none';
        console.log("‚úÖ Switched to Spotify UI");
      } else {
        yBtn.style.color = '#FF0000';
        yBtn.style.borderBottom = '2px solid #FF0000';
        sBtn.style.color = '#aaa';
        sBtn.style.borderBottom = 'none';

        ySec.style.display = 'block';
        sSec.style.display = 'none';
        console.log("‚úÖ Switched to YouTube UI");

        // Load YT API if not loaded
        if (!window.YT) {
          console.log("‚è≥ Loading YouTube IFrame API...");
          const tag = document.createElement('script');
          tag.src = "https://www.youtube.com/iframe_api";
          const firstScriptTag = document.getElementsByTagName('script')[0];
          firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        } else {
          console.log("‚ÑπÔ∏è YouTube API already loaded.");
        }
      }
    }

    // --- YouTube Controller ---
    const YouTubeController = {
      // STATE
      accessToken: localStorage.getItem('yt_access_token'),
      expiry: parseInt(localStorage.getItem('yt_expiry') || '0'),
      volume: 100,
      player: null,
      playerReady: false,
      playlistId: null,
      isDucked: false,

      // AUTH
      // AUTH
      async login() {
        const clientId = GOOGLE_CLIENT_ID;
        console.log("üîë [YT] Login requested with Client ID:", clientId);
        // Basic check: Ensure it's not empty and has some length
        if (!clientId || clientId.length < 10) {
          console.error("‚ùå Invalid Google Client ID:", clientId);
          alert("Please configure GOOGLE_CLIENT_ID in the code!");
          return;
        }

        // Google OAuth 2.0 Implicit Flow (Simplest for client-side)
        const redirectUri = window.location.origin + window.location.pathname;
        console.log("üîó Generated Redirect URI:", redirectUri);

        // Debugging aid for the user
        // Remove this alert after setup is done, or keep it if helpful?
        // prefer simpler approach:

        const scope = 'https://www.googleapis.com/auth/youtube.readonly';

        const url = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=token&scope=${encodeURIComponent(scope)}&state=yt_login`;

        // Check if we are potentially mismatching
        console.log("üöÄ Redirecting to:", url);

        window.location = url;
      },

      handleAuthCallback() {
        const hash = window.location.hash.substring(1);
        const params = new URLSearchParams(hash);
        if (params.has('access_token')) {
          this.accessToken = params.get('access_token');
          const expIn = params.get('expires_in');
          this.expiry = Date.now() + (parseInt(expIn) * 1000);

          localStorage.setItem('yt_access_token', this.accessToken);
          localStorage.setItem('yt_expiry', this.expiry);

          // Clear hash
          window.history.pushState("", document.title, window.location.pathname);

          this.initUI();
        } else if (this.accessToken) {
          if (Date.now() < this.expiry) {
            this.initUI();
          } else {
            // expired
            this.logout();
          }
        }
      },

      logout() {
        if (!confirm("Are you sure you want to logout from YouTube?")) return;
        this.accessToken = null;
        localStorage.removeItem('yt_access_token');
        localStorage.removeItem('yt_expiry');
        location.reload();
      },

      async initUI() {
        document.getElementById('ytLogin').style.display = 'none';
        document.getElementById('ytPlayerUI').style.display = 'flex';

        // Fetch User Profile (Channels API)
        try {
          const res = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', {
            headers: { 'Authorization': `Bearer ${this.accessToken}` }
          });
          const data = await res.json();
          if (data.items && data.items.length > 0) {
            document.getElementById('ytUserName').textContent = data.items[0].snippet.title;
          }
        } catch (e) {
          console.error("YT Profile Error", e);
        }

        // Fetch Playlists
        await this.fetchPlaylists();
      },

      async fetchPlaylists() {
        if (!this.accessToken) return;
        try {
          const res = await fetch('https://www.googleapis.com/youtube/v3/playlists?part=snippet&mine=true&maxResults=50', {
            headers: { 'Authorization': `Bearer ${this.accessToken}` }
          });
          const data = await res.json();

          const sel = document.getElementById('ytPlaylistSelect');
          sel.innerHTML = '<option value="">-- –ò–∑–±–µ—Ä–∏ –ü–ª–µ–π–ª–∏—Å—Ç --</option>';

          if (data.items) {
            data.items.forEach(item => {
              const opt = document.createElement('option');
              opt.value = item.id;
              opt.textContent = item.snippet.title;
              sel.appendChild(opt);
            });
          }
        } catch (e) {
          console.error("YT Fetch Error", e);
        }
      },

      refreshPlaylists() {
        this.fetchPlaylists();
      },

      // Fetch songs from playlist
      async fetchPlaylistItems(pid) {
        const listDiv = document.getElementById('ytSongList');
        listDiv.innerHTML = '<div style="padding:10px; text-align:center;">Loading songs...</div>';

        try {
          const res = await fetch(`https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${pid}&maxResults=50`, {
            headers: { 'Authorization': `Bearer ${this.accessToken}` }
          });
          const data = await res.json();

          listDiv.innerHTML = '';
          if (data.items) {
            data.items.forEach((item, index) => {
              const title = item.snippet.title;
              const thumb = item.snippet.thumbnails.default ? item.snippet.thumbnails.default.url : '';

              const div = document.createElement('div');
              div.className = 'song-item';
              // Store index valid for current playlist
              div.dataset.index = index;
              div.onclick = () => {
                this.playIndex(index);
              };

              div.innerHTML = `
                        <img src="${thumb}" class="song-thumb" alt="thumb">
                        <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${title}</div>
                     `;
              listDiv.appendChild(div);
            });
          } else {
            listDiv.innerHTML = '<div style="padding:10px; text-align:center;">No songs found.</div>';
          }
        } catch (e) {
          console.error("YT items error", e);
          listDiv.innerHTML = '<div style="padding:10px; text-align:center; color:red;">Error loading songs.</div>';
        }
      },

      playIndex(index) {
        if (this.player && this.playerReady) {
          this.player.playVideoAt(index);
          this.updateActiveItem(index);
        }
      },

      updateActiveItem(index) {
        // Visual highlight
        const listDiv = document.getElementById('ytSongList');
        Array.from(listDiv.children).forEach(child => {
          if (child.dataset.index == index) child.classList.add('active');
          else child.classList.remove('active');
        });
      },

      // PLAYER
      selectPlaylist(pid) {
        this.playlistId = pid;
        // Fetch songs list
        this.fetchPlaylistItems(pid);

        if (this.player && this.playerReady) {
          this.player.loadPlaylist({ listType: 'playlist', list: pid });
        } else {
          this.initPlayer();
        }
      },

      initPlayer() {
        if (this.player) return; // already init
        if (!window.YT || !window.YT.Player) return; // wait for API

        this.player = new YT.Player('yt_player_div', {
          height: '200',
          width: '200',
          playerVars: {
            'playsinline': 1,
            'controls': 0
          },
          events: {
            'onReady': (event) => {
              this.playerReady = true;
              if (this.playlistId) {
                this.player.loadPlaylist({ listType: 'playlist', list: this.playlistId });
              }
            },
            'onStateChange': (event) => {
              // -1 unstarted, 0 ended, 1 playing, 2 paused, 3 buffering, 5 cued
              this.updateStatus(event.data);
            }
          }
        });
      },

      togglePlay() {
        if (!this.player || !this.playerReady) return;
        const state = this.player.getPlayerState();
        if (state === 1) { // Playing
          this.player.pauseVideo();
        } else {
          this.player.playVideo();
        }
      },

      play() {
        if (this.player && this.playerReady) this.player.playVideo();
      },
      pause() {
        if (this.player && this.playerReady) this.player.pauseVideo();
      },
      next() {
        if (this.player && this.playerReady) this.player.nextVideo();
      },
      prev() {
        if (this.player && this.playerReady) this.player.previousVideo();
      },

      setVolume(val) {
        this.volume = parseInt(val);
        document.getElementById('ytVolValue').textContent = val + '%';

        // Apply if not ducked
        if (!this.isDucked) {
          if (this.player && this.playerReady) this.player.setVolume(this.volume);
        } else {
          if (this.player && this.playerReady) this.player.setVolume(Math.round(this.volume * 0.4));
        }
      },

      setDucked(shouldDuck) {
        this.isDucked = shouldDuck;
        const target = shouldDuck ? Math.round(this.volume * 0.4) : this.volume;
        if (this.player && this.playerReady) {
          this.player.setVolume(target);
        }
      },

      // Update UI based on state
      updateStatus(stateData) {
        const lbl = document.getElementById('ytNowPlaying');

        if (stateData === 1) {
          // btn.textContent = "‚è∏"; // Removed duplicate button logic
          try {
            // Find current index
            const idx = this.player.getPlaylistIndex();
            this.updateActiveItem(idx);

            const vData = this.player.getVideoData();
            if (vData && vData.title) lbl.textContent = "‚ñ∂ " + vData.title;
          } catch (e) { }
        } else {
          // btn.textContent = "‚ñ∂";
          lbl.textContent = "‚è∏ Paused";
        }
      }
    };

    // Global callback for YouTube API
    function onYouTubeIframeAPIReady() {
      YouTubeController.initPlayer();
    }

    // Init on load
    window.addEventListener('load', () => {
      SpotifyController.handleCallback();
      // Check for YT auth
      if (window.location.hash.includes('access_token') && window.location.hash.includes('state=yt_login')) {
        YouTubeController.handleAuthCallback();
        switchMusicService('youtube');
      } else if (localStorage.getItem('yt_access_token')) {
        // Auto-check if token exists, maybe init UI?
        // Maybe don't auto-switch unless user wants?
        // Let's just init logic
        YouTubeController.handleAuthCallback();
      }
    });

    // Helper for Timer integration
    function setVolume(levelRatio) {
      // levelRatio: 1.0 = Normal, 0 = Duck (or mute)
      if (levelRatio < 0.5) {
        SpotifyController.setDucked(true);
        YouTubeController.setDucked(true);
      } else {
        SpotifyController.setDucked(false);
        YouTubeController.setDucked(false);
      }
    }


    function speak(text) {
      if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = "en-US";
      utterance.rate = 1.2;
      window.speechSynthesis.speak(utterance);
    }

    // --- Timer Logic ---
    function updateInputs() {
      // Validate inputs
      const safeInt = (id) => {
        const el = document.getElementById(id);
        let val = parseInt(el.value) || 0;
        if (val < 0) { val = 0; el.value = 0; }
        return val;
      }

      workDuration = Math.max(1, safeInt("workTime"));
      restDuration = Math.max(0, safeInt("restTime"));
      totalSets = Math.max(1, safeInt("sets"));
      prepDuration = Math.max(0, safeInt("prepTime"));

      // Formula: Prep + (Work+Rest)*Sets - LastRest
      // Assuming Rest is AFTER Work, except the last one?
      // User said: "15s work * 3 sets + 2s rest + 10s prep = 59s" (15*3 + 2*2 + 10 = 59)
      // Standard logic: Sets * Work + (Sets-1) * Rest + Prep

      const restsCount = totalSets > 0 ? totalSets - 1 : 0;
      totalWorkoutSeconds = prepDuration + (workDuration * totalSets) + (restDuration * restsCount);

      // Update Total Time Display
      const ttEl = document.getElementById("totalTimeDisplay");
      if (ttEl) {
        ttEl.textContent = "–û–±—â–æ –≤—Ä–µ–º–µ: " + formatDurationVerbose(totalWorkoutSeconds);
      }

      let requestedCountdown =
        parseInt(document.getElementById("voiceCountdown").value) || 0;
      let minInterval =
        isPrep && prepDuration > 0
          ? Math.min(workDuration, restDuration || workDuration, prepDuration)
          : Math.min(workDuration, restDuration || workDuration);

      if (requestedCountdown >= minInterval && minInterval > 0) {
        countdownThreshold = minInterval - 1;
      } else {
        countdownThreshold = Math.max(0, requestedCountdown);
      }
      document.getElementById("voiceCountdown").value = countdownThreshold;
    }

    function drawDisplay() {
      timeText.textContent = formatTime(currentTime);
      timeText.textContent = formatTime(currentTime);

      const totalRests = totalSets > 0 ? totalSets - 1 : 0;
      let currentRestCount = 0;
      if (isPrep) {
        currentRestCount = 0;
      } else if (!isWork) {
        // Resting (Rest comes after Work set X)
        currentRestCount = currentSet;
      } else {
        // Working (We have finished set X-1 rests)
        currentRestCount = currentSet - 1;
      }
      // Safety clamp
      if (currentRestCount > totalRests) currentRestCount = totalRests;

      setText.textContent = `–°–µ—Ä–∏—è: ${currentSet} / ${totalSets} | –ü–æ—á–∏–≤–∫–∏: ${currentRestCount} / ${totalRests}`;

      const progressPercentValue =
        Math.min(
          100,
          Math.round((elapsedSeconds / totalWorkoutSeconds) * 100)
        ) || 0;

      document.getElementById("progressBar").style.width =
        progressPercentValue + "%";
      document.getElementById("progressPercent").textContent =
        progressPercentValue + "%";

      timerDisplay.classList.remove("finished-mode");
      if (isPrep) {
        statusText.textContent = "–ü–û–î–ì–û–¢–û–í–ö–ê";
        timerDisplay.style.borderColor = "var(--highlight)";
      } else if (isWork) {
        statusText.textContent = "GO / –†–ê–ë–û–¢–ê";
        timerDisplay.classList.remove("rest-mode");
        timerDisplay.classList.add("work-mode");
        timerDisplay.style.borderColor = "";
      } else {
        statusText.textContent = "BREAK / –ü–û–ß–ò–í–ö–ê";
        timerDisplay.classList.remove("work-mode");
        timerDisplay.classList.add("rest-mode");
      }
    }

    function startTimer() {
      if (isRunning) return;

      // FIX: –ê–∫–æ –µ –§–ò–ù–ê–õ, –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Ä–µ—Å—Ç–∞—Ä—Ç–∏—Ä–∞–π –ø—Ä–µ–¥–∏ —Å—Ç–∞—Ä—Ç
      if (timerDisplay.classList.contains("finished-mode")) {
        resetTimer();
      }

      requestWakeLock(); // <--- –ê–∫—Ç–∏–≤–∏—Ä–∞ "–±–µ–∑ –∑–∞—Å–ø–∏–≤–∞–Ω–µ" –∏ –ø–æ–∫–∞–∑–≤–∞ GIF-–∞

      // 4. –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –ª–æ–≥–∏–∫–∞ –Ω–∞ —Ç–∞–π–º–µ—Ä–∞
      if (audioCtx.state === "suspended") audioCtx.resume();
      updateInputs();

      // Music Play
      if (activeMusicService === 'spotify') {
        if (SpotifyController.accessToken) SpotifyController.play();
      } else if (activeMusicService === 'youtube') {
        if (YouTubeController.accessToken) YouTubeController.play();
      }

      // –ü—ä—Ä–≤–æ–Ω–∞—á–∞–ª–µ–Ω —Å—Ç–∞—Ä—Ç (–∞–∫–æ –µ –Ω–∞—á–∞–ª–æ)
      // FIX: –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ elapsedSeconds, –∑–∞—â–æ—Ç–æ –ø—Ä–∏ Reset –≤—Ä–µ–º–µ—Ç–æ —Å–µ –Ω—É–ª–∏—Ä–∞, –Ω–æ currentTime –º–æ–∂–µ –¥–∞ –µ > 0 (–∞–∫–æ –∏–º–∞ Prep)
      if (elapsedSeconds === 0) {
        if (prepDuration > 0) {
          isPrep = true;
          currentTime = prepDuration;
          speak("Prepare");
        } else {
          currentTime = workDuration;
          speak("Starting Workout");
        }
      }

      isRunning = true;
      drawDisplay();
      console.log("‚è±Ô∏è Timer started");

      // 5. –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ (—Ç–æ–≤–∞ –µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–∏—è—Ç setInterval, –∫–æ–π—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–º–∞)
      timerInterval = setInterval(() => {
        tick();
      }, 1000);
    }

    function stopTimer(pauseAudio = true) {
      clearInterval(timerInterval);
      window.speechSynthesis.cancel(); // <--- –°–ø–∏—Ä–∞–º–µ –≥–æ–≤–æ—Ä–∞ –≤–µ–¥–Ω–∞–≥–∞ –ø—Ä–∏ –ø–∞—É–∑–∞
      isRunning = false;

      releaseWakeLock(); // <--- –ü–æ–∑–≤–æ–ª—è–≤–∞ –∑–∞—Å–ø–∏–≤–∞–Ω–µ –∏ —Å–∫—Ä–∏–≤–∞ GIF-–∞

      console.log("‚è±Ô∏è Timer paused/stopped");

      if (pauseAudio) {
        if (activeMusicService === 'spotify') SpotifyController.pause();
        else if (activeMusicService === 'youtube') YouTubeController.pause();
      }
      SpotifyController.setDucked(false);
      YouTubeController.setDucked(false);
    }

    function resetTimer() {
      stopTimer();
      elapsedSeconds = 0;
      document.getElementById("progressBar").style.width = "0%";
      document.getElementById("progressPercent").textContent = "0%";

      // FIX: –ù—É–ª–∏—Ä–∞–º–µ –±—Ä–æ—è—á–∞ –Ω–∞ —Å–µ—Ä–∏–∏—Ç–µ
      currentSet = 1;

      isWork = true;
      isPrep = true;
      updateInputs();

      currentTime = prepDuration > 0 ? prepDuration : workDuration;
      if (prepDuration <= 0) isPrep = false;

      statusText.textContent = isPrep ? "–ü–û–î–ì–û–¢–û–í–ö–ê" : "–ì–û–¢–û–í?";
      statusText.textContent = isPrep ? "–ü–û–î–ì–û–¢–û–í–ö–ê" : "–ì–û–¢–û–í?";
      timeText.textContent = formatTime(currentTime);

      const totalRests = totalSets > 0 ? totalSets - 1 : 0;
      setText.textContent = `–°–µ—Ä–∏—è: 0 / ${totalSets} | –ü–æ—á–∏–≤–∫–∏: 0 / ${totalRests}`;

      timerDisplay.classList.remove("rest-mode", "finished-mode");
      timerDisplay.classList.add("work-mode");

      if (activeMusicService === 'spotify') SpotifyController.pause();
      else if (activeMusicService === 'youtube') YouTubeController.pause();

      SpotifyController.setDucked(false);
      YouTubeController.setDucked(false);
      console.log("üîÑ Timer reset");
    }

    function tick() {
      elapsedSeconds++;
      currentTime--;
      drawDisplay();

      let shouldCount = false;
      if (isPrep) shouldCount = true;
      if (isWork && cbBeforeRest.checked) shouldCount = true;
      if (!isWork && cbBeforeWork.checked) shouldCount = true;

      if (
        currentTime <= countdownThreshold &&
        currentTime > 0 &&
        shouldCount
      ) {
        playBeep(660, 0.1); // –ü–æ-–≤–∏—Å–æ–∫ —Ç–æ–Ω –∑–∞ —Ñ–∏–Ω–∞–ª–Ω–∏—Ç–µ —Å–µ–∫—É–Ω–¥–∏
        setVolume(0); // Duck logic handled by setVolume(0) -> DUCKED
        speak(currentTime);
      } else {
        // Restore volume if needed
        // Since we don't track state nicely, just set to 1.0 (Normal) constantly?
        // Optimization: Check current volume?
        // But simplified: Just setVolume(1.0)
        setVolume(1.0);
      }

      if (currentTime <= 0) {
        setVolume(0); // Duck

        if (isPrep) {
          isPrep = false;
          currentTime = workDuration;
          speak("Go");
        } else if (isWork) {
          if (currentSet >= totalSets) {
            currentTime = 0;
            drawDisplay();
            finishWorkout();
            return;
          }
          isWork = false;
          currentTime = restDuration;
          if (cbBeforeRest.checked) speak("Break");
        } else {
          isWork = true;
          currentSet++;
          currentTime = workDuration;
          if (cbBeforeWork.checked) speak("Go");
        }

        setTimeout(() => {
          if (isRunning) setVolume(1.0);
        }, 1200);

        drawDisplay();
      }
    }

    function finishWorkout() {
      stopTimer(false);
      setVolume(0); // Duck

      timerDisplay.classList.remove("work-mode", "rest-mode");
      timerDisplay.classList.add("finished-mode");
      statusText.textContent = "–§–ò–ù–ê–õ!";
      console.log("üèÅ Workout finished!");

      playVictorySound();

      setTimeout(() => {
        speak("Workout Complete");
      }, 1500);

      const stopMusic = document.getElementById("stopMusicOnFinish").checked;

      setTimeout(() => {
        if (stopMusic) {
          if (activeMusicService === 'spotify') SpotifyController.pause();
          else if (activeMusicService === 'youtube') YouTubeController.pause();
        } else {
          SpotifyController.setDucked(false);
          YouTubeController.setDucked(false);
        }
      }, 4000);

      isWork = false;
      isPrep = false;
    }

    document.getElementById("timeText").textContent =
      document.getElementById("workTime").value;

    function toggleSettings() {
      const panel = document.getElementById("settingsPanel");
      panel.classList.toggle("collapsed");
      if (panel.classList.contains("collapsed")) {
        document
          .getElementById("timerDisplay")
          .scrollIntoView({ behavior: "smooth" });
      }
    }

    const inputIds = [
      "prepTime",
      "workTime",
      "restTime",
      "sets",
      "voiceCountdown",
      "countBeforeRest",
      "countBeforeWork",
      "stopMusicOnFinish",
    ];
    inputIds.forEach((id) => {
      const el = document.getElementById(id);
      el.addEventListener("change", () => {
        const val = el.type === "checkbox" ? el.checked : el.value;
        localStorage.setItem("fitness_timer_" + id, val);

        updateInputs();

        // If timer is not running and hasn't really started (no elapsed time),
        // update the display immediately to show new Prep/Work time.
        if (!isRunning && elapsedSeconds === 0) {
          // Re-calc start time
          let newPrep = parseInt(document.getElementById("prepTime").value) || 0;
          let newWork = parseInt(document.getElementById("workTime").value) || 0;

          // Sync variables just in case
          prepDuration = Math.max(0, newPrep);
          workDuration = Math.max(1, newWork);
          // We use the function logic mainly, but here we can just reset logic
          // Easier: call resetTimer() without sound effect? 
          // resetTimer() stops, resets elapsed, and draws display. Perfect.
          resetTimer();
        }
      });

      // Input validation for negative numbers
      if (el.type === "number") {
        el.addEventListener("input", function () {
          if (this.value < 0) this.value = 0;
        });
      }
    });

    // –ó–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ
    window.addEventListener("load", () => {
      inputIds.forEach((id) => {
        const saved = localStorage.getItem("fitness_timer_" + id);
        if (saved !== null) {
          const el = document.getElementById(id);
          if (el.type === "checkbox") el.checked = saved === "true";
          else el.value = saved;
        }
      });
      // Volume Slider Listener
      const volSlider = document.getElementById("volumeSlider");
      if (volSlider) {
        volSlider.addEventListener("input", (e) => SpotifyController.setMasterVolume(e.target.value));
      }

      const savedVol = localStorage.getItem("sp_volume");
      if (savedVol !== null) {
        SpotifyController.userVolume = parseInt(savedVol);
        if (volSlider) volSlider.value = savedVol;
        const volVal = document.getElementById("volValue");
        if (volVal) volVal.textContent = savedVol + "%";
      }

      updateInputs();
      updateInputs();

      const tSets = parseInt(document.getElementById("sets").value) || 0;
      const tRests = tSets > 0 ? tSets - 1 : 0;
      setText.textContent = `–°–µ—Ä–∏—è: 0 / ${tSets} | –ü–æ—á–∏–≤–∫–∏: 0 / ${tRests}`;

      timeText.textContent = formatTime(prepDuration > 0 ? prepDuration : workDuration);
    });

    // Theme logic
    (function () {
      const THEME_KEY = "fitness_theme";
      const btn = document.getElementById("themeToggle");

      function applyTheme(theme) {
        document.body.classList.remove("light-theme", "dark-theme");
        document.body.classList.add(
          theme === "light" ? "light-theme" : "dark-theme"
        );
        if (btn) {
          const pressed = theme === "light" ? "true" : "false";
          btn.setAttribute("aria-pressed", pressed);
        }
      }

      function detectSystemTheme() {
        try {
          return window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: light)").matches
            ? "light"
            : "dark";
        } catch (e) {
          return "dark";
        }
      }

      function initTheme() {
        let saved = localStorage.getItem(THEME_KEY);
        if (saved !== "light" && saved !== "dark")
          saved = detectSystemTheme();
        applyTheme(saved);
      }

      function toggleTheme() {
        const isLight = document.body.classList.contains("light-theme");
        const next = isLight ? "dark" : "light";
        applyTheme(next);
        localStorage.setItem(THEME_KEY, next);
      }

      if (btn) {
        btn.addEventListener("click", toggleTheme);
        btn.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggleTheme();
          }
        });
      }
      document.addEventListener("DOMContentLoaded", initTheme);
    })();

    function formatTime(s) {
      const mm = Math.floor(s / 60);
      const ss = s % 60;
      return `${String(mm).padStart(2, "0")}:${String(ss).padStart(2, "0")}`;
    }

    function formatDurationVerbose(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;

      let parts = [];
      if (h > 0) parts.push(`${h} —á.`);
      if (m > 0) parts.push(`${m} –º–∏–Ω.`);
      if (s > 0 || parts.length === 0) parts.push(`${s} —Å–µ–∫.`);

      return parts.join(" ");
    }

    timeText.textContent = formatTime(currentTime);


    // –ü–æ–ø—Ä–∞–≤–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ Service Worker
    if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('‚úÖ Service Worker registered!'))
          .catch(err => console.error('‚ùå Service Worker failed:', err));
      });
    }

    // --- Presets Logic ---
    let savedPresets = [];
    const PRESETS_KEY = "fitness_presets_v1";

    function loadPresetsFromStorage() {
      const raw = localStorage.getItem(PRESETS_KEY);
      if (raw) {
        try {
          savedPresets = JSON.parse(raw);
        } catch (e) {
          console.error("Presets parse error", e);
          savedPresets = [];
        }
      }
      renderPresets();
    }

    function savePreset() {
      const nameInput = document.getElementById("presetName");
      const name = nameInput.value.trim();
      if (!name) {
        alert("–ú–æ–ª—è –≤—ä–≤–µ–¥–µ—Ç–µ –∏–º–µ –Ω–∞ —Ä–µ–∂–∏–º–∞.");
        return;
      }

      const currentSettings = {
        name: name,
        prep: document.getElementById("prepTime").value,
        work: document.getElementById("workTime").value,
        rest: document.getElementById("restTime").value,
        sets: document.getElementById("sets").value
      };

      savedPresets.push(currentSettings);
      localStorage.setItem(PRESETS_KEY, JSON.stringify(savedPresets));

      nameInput.value = "";
      renderPresets();
    }

    function deletePreset(index, event) {
      event.stopPropagation(); // prevent clicking the item to load
      if (confirm("–°–∏–≥—É—Ä–Ω–∏ –ª–∏ —Å—Ç–µ, —á–µ –∏—Å–∫–∞—Ç–µ –¥–∞ –∏–∑—Ç—Ä–∏–µ—Ç–µ —Ç–æ–∑–∏ —Ä–µ–∂–∏–º?")) {
        savedPresets.splice(index, 1);
        localStorage.setItem(PRESETS_KEY, JSON.stringify(savedPresets));
        renderPresets();
      }
    }

    function loadPreset(index) {
      const p = savedPresets[index];
      if (!p) return;

      document.getElementById("prepTime").value = p.prep;
      document.getElementById("workTime").value = p.work;
      document.getElementById("restTime").value = p.rest;
      document.getElementById("sets").value = p.sets;

      // Trigger updates
      inputIds.forEach(id => {
        if (['prepTime', 'workTime', 'restTime', 'sets'].includes(id)) {
          localStorage.setItem("fitness_timer_" + id, p[id === 'prepTime' ? 'prep' : id === 'workTime' ? 'work' : id === 'restTime' ? 'rest' : 'sets']);
        }
      });

      updateInputs();
      resetTimer();

      toggleSettings(); // Close settings to show readiness

      // Visual feedback
      statusText.textContent = "–ó–ê–†–ï–î–ï–ù: " + p.name;
      setTimeout(() => {
        if (!isRunning) statusText.textContent = isPrep ? "–ü–û–î–ì–û–¢–û–í–ö–ê" : "–ì–û–¢–û–í?";
      }, 2000);
    }

    function renderPresets() {
      const list = document.getElementById("presetsList");
      list.innerHTML = "";

      savedPresets.forEach((p, i) => {
        const li = document.createElement("li");
        li.className = "preset-item";
        li.innerHTML = `
                <span class="preset-name">${p.name}</span>
                <span style="font-size:0.8rem; color:#aaa; margin-right:10px;">
                   ${p.work}s / ${p.rest}s x ${p.sets}
                </span>
                <button class="preset-delete" onclick="deletePreset(${i}, event)">‚úñ</button>
            `;
        li.onclick = () => loadPreset(i);
        list.appendChild(li);
      });
    }

    window.addEventListener("load", loadPresetsFromStorage);


  </script>

  <!-- Info Modal Markup -->
  <div id="infoModal" class="modal-overlay">
    <div class="modal-content">
      <button class="modal-close" onclick="toggleInfoModal()">√ó</button>
      <h2>–ó–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ</h2>
      <div class="modal-desc">
        <p>–¢–æ–≤–∞ –µ –í–∞—à–∏—è—Ç —É–ª—Ç—Ä–∞ –ª–µ–∫ –∏ –º–æ—â–µ–Ω —Ñ–∏—Ç–Ω–µ—Å –ø–æ–º–æ—â–Ω–∏–∫! üéßüèãÔ∏è‚Äç‚ôÇÔ∏è</p>
        <p>Fitness Timer & DJ —É–ø—Ä–∞–≤–ª—è–≤–∞ –í–∞—à–∏—Ç–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –∏ –º—É–∑–∏–∫–∞ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Å–µ—Ä–∏–∏—Ç–µ, –∏–∑–±–µ—Ä–µ—Ç–µ –ª—é–±–∏–º–∏—Ç–µ
          —Å–∏
          mp3 —Ñ–∞–π–ª–æ–≤–µ –∏ –æ—Å—Ç–∞–≤–µ—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ
          –¥–∞ –±—ä–¥–µ –í–∞—à–∏—è—Ç –ª–∏—á–µ–Ω DJ ‚Äì –Ω–∞–º–∞–ª—è–≤–∞ –º—É–∑–∏–∫–∞—Ç–∞ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –ø–æ—á–∏–≤–∫–∞ –∏ —è —É—Å–∏–ª–≤–∞, –∫–æ–≥–∞—Ç–æ –µ –≤—Ä–µ–º–µ –∑–∞ —Ä–∞–±–æ—Ç–∞! –î–æ–±—Ä–µ
          –µ
          –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç–µ Chrome –±—Ä–∞—É–∑—ä—Ä –∏–ª–∏ –¥—Ä—É–≥ –∫–æ–π—Ç–æ –Ω–µ –µ –º–µ—Å–∏–¥–∂ –±–∞–∑–∏—Ä–∞–Ω –æ—Ç –Ω—è–∫–æ—è —á–∞—Ç –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞.</p>
      </div>
      <button id="pwaInstallBtn" class="pwa-install-btn">üì≤ –ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ</button>
    </div>
  </div>

  <script>
    // --- Info Modal & PWA Logic ---
    function toggleInfoModal() {
      const modal = document.getElementById('infoModal');
      modal.classList.toggle('visible');
    }

    // Close modal when clicking outside
    document.getElementById('infoModal').addEventListener('click', function (e) {
      if (e.target === this) {
        toggleInfoModal();
      }
    });

    // PWA Install Prompt
    let deferredPrompt;
    const installBtn = document.getElementById('pwaInstallBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent Chrome 67 and earlier from automatically showing the prompt
      e.preventDefault();
      // Stash the event so it can be triggered later.
      deferredPrompt = e;
      // Update UI to notify the user they can add to home screen
      installBtn.style.display = 'inline-block';

      console.log('‚úÖ PWA Install Prompt captured');
    });

    installBtn.addEventListener('click', (e) => {
      // hide our user interface that shows our A2HS button
      installBtn.style.display = 'none';
      // Show the prompt
      if (deferredPrompt) {
        deferredPrompt.prompt();
        // Wait for the user to respond to the prompt
        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the A2HS prompt');
          } else {
            console.log('User dismissed the A2HS prompt');
          }
          deferredPrompt = null;
        });
      }
    });
  </script>
</body>

</html>